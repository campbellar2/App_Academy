# Software Engineering Foundation Notes #

#######
# Advanced Ruby #

#Implicit Returns

# Less preferred
def get_avg(num_1, num_2)
    return (num_1 + num_2) / 2
end

# Preferred by a Rubyist
def get_avg(num_1, num_2)
    (num_1 + num_2) / 2
end

#Omitting parentheses for method calls with no arguments

def say_hi
    puts "hi"
end

# Less preferred 
say_hi()

# Preferred by a Rubyist
say_hi

#Use single line conditionals when possible

raining = true

# Less preferred
if raining
    puts "don't forget an umbrella!"
end

# Preferred by a Rubyist
puts "don't forget an umbrella!" if raining

#Use built-in methods

num = 6

# Less preferred
p num % 2 == 0

# Preferred by a Rubyist
p num.even?

people = ["Joey", "Bex", "Andrew"]

# Less preferred
p people[people.length - 1]

# Preferred by a Rubyist
p people[-1]
p people.last

#Use enumerables to iterate

# Less preferred
def repeat_hi(num)
    i = 0
    while i < num
        puts "hi"
        i += 1
    end
end

# Preferred by a Rubyist
def repeat_hi(num)
    num.times { puts "hi" }
end

# Less preferred
def all_numbers_even?(nums)
    nums.each do |num|
        return false if num % 2 != 0
    end

    true
end

# Preferred by a Rubyist
def all_numbers_even?(nums)
    nums.all? { |num| num.even? }
end

##################################

# Common Enumerables #

# all?
# Return true when all elements result in true when passed into the block.
p [2, 4, 6].all? { |el| el.even? }  # => true
p [2, 3, 6].all? { |el| el.even? }  # => false

# any?
# Return true when all at least one element results in true when passed into the block.
p [3, 4, 7].any? { |el| el.even? }  # => true
p [3, 5, 7].any? { |el| el.even? }  # => false

# none?
# Return true when no elements result in true when passed into the block.
p [1, 3, 5].none? { |el| el.even? } # => true
p [1, 4, 5].none? { |el| el.even? } # => false

# one?
# Return true when exactly one element results in true when passed into the block.
p [1, 4, 5].one? { |el| el.even? }  # => true
p [1, 4, 6].one? { |el| el.even? }  # => false
p [1, 3, 5].one? { |el| el.even? }  # => false

# count
# Return a number representing the count of elements that result in true when passed into the block.
p [1, 2, 3, 4, 5, 6].count { |el| el.even? }    # => 3
p [1, 3, 5].count { |el| el.even? }             # => 0

# sum
# Return the total sum of all elements
p [1, -3, 5].sum   # => 3

# max and min
# Return the maximum or minimum element
p [1, -3, 5].min    # => -3
p [1, -3, 5].max    # => 5
p [].max            # => nil

# flatten 
# Return the 1 dimensional version of any multidimensional array
multi_d = [
    [["a", "b"], "c"],
    [["d"], ["e"]],
    "f"
]

p multi_d.flatten   # => ["a", "b", "c", "d", "e", "f"]

#############################

# Symbols

# Ruby has an additional data type that is similar to Strings, called Symbols.
# In Ruby, we can denote a symbol using a colon (:) before writing characters. 
# Where a string is wrapped in quotes, a symbol just has a leading colon. 
#Both strings and symbols contain many characters, but they are not equivalent.

str = "hello"   # the string 
sym = :hello    # the symbol

p str.length    # => 5
p sym.length    # => 5

p str[1]        # => "e"
p sym[1]        # => "e"

p str == sym    # => false
# a string is different from a symbol!

# The main difference between a string and a symbol, is that symbols are immutable, and can never be changed
str = "hello"
sym = :hello

str[0] = "x"
sym[0] = "x"

p str   # => "xello"
p sym   # => :hello

# Symbols as hash keys
my_bootcamp = { :name=>"App Academy", :color=>"red", :locations=>["NY", "SF", "ONLINE"] }
p my_bootcamp           # => {:name=>"App Academy", :color=>"red", :locations=>["NY", "SF", "ONLINE"]}
p my_bootcamp[:color]   #=> "red

#When initializing a hash with symbol keys, Ruby offers a shortcut. 
#We can drop the rocket (=>) and move the colon (:) to the right of the symbol
my_bootcamp = { name:"App Academy", color:"red", locations:["NY", "SF", "ONLINE"] }
p my_bootcamp           # => {:name=>"App Academy", :color=>"red", :locations=>["NY", "SF", "ONLINE"]}
p my_bootcamp[:color]   #=> "red

# This shortcut is only allowed when initializing the symbols in the hash. 
# When getting a value from the hash after initialization, we must always put the colon on the left like normal.
# hash[:key] is the correct syntax. Writing hash[key:] is invalid.

##############################
