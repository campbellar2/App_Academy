#App Academy Open Notes#

#### Enumerables & Ranges ####

#   Array Methods ####################################
# << adds one element to the end of an array, evaluates to the array

# array.push == adds one or multiple elements, also evaluates to the array
# array.pop == removes the last element of the array, BUT evaluates to the element removed

# array.unshift == adds an element to the front of the array, evaluates to the array
# array.shift == removes the first element of an array, BUT evaluates to the element removed

###############

# array/string.index(element) evaluates to the index where element is found
# array/string.include?(element) evaluates to a boolean indicating if the element is found

# array/string.reverse evaluates to a new reverse version of the array or string, NOTE doesnt reverse it by itself, need to set to a variable or 'puts' it
# array/string.reverse! will reverse an array/string on its own, altering the original array

##############

# array/string slicing
#   array[startIndex..endIndex] grabs elements from startIndex to endIndex, inclusive
#   array[startIndex...endIndex] grabs elements from startIndex to endIndex, NOT inclusive of endIndex
#       NOTE - -1, -2, -3 can be used to refer to the last, second to last, third to last indices, respectively 

##############

# string.split evaluates to an array
#   string.split("where you want to cut the string, this element gets cut out of the array")
# array.join evaluates to a string
#   array.join("what element you want between the elements of the array")
# combing these allows you to replace what you can with what you join with

########################################################

#   Enumerable Methods #################################
# array
#   .each

#   array.each{ |month| puts month } with |month| acting like a variable
#       OR      #
#   array.each do |ele|
#       puts ele
#       puts "---"
#   end 
#   For multiple lines of code

#   .each_with_index
#       this outputs two variables, ie |ele, index|

# string        Same as above, with strings instead of arrays
#   .each_char
#   .each_char.with_index

# range enumerables
#   (start..end).each, iterate from start to end (inclusive)
#   (start...end).each, iterate from start to end (excluding end)

# num.times {} runes the code block num times

####################

#   EXAMPLES   #

#def to_initials(name)
#    initials = ""
#    half = name.split(" ")
#    half.each { |part| initials += part[0]}
#    return initials
#end

#puts to_initials("Kelvin Bridges")      # => "KB"
#puts to_initials("Michaela Yamamoto")   # => "MY"
#puts to_initials("Mary La Grange")      # => "MLG"


#def first_in_array(arr, el1, el2)
#    if arr.index(el1) < arr.index(el2)
#        return el1
#    end
#    if arr.index(el2) < arr.index(el1)
#        return el2
#    end
#end

#puts first_in_array(["a", "b", "c", "d"], "d", "b"); # => "b"
#puts first_in_array(["cat", "bird" ,"dog", "mouse" ], "dog", "mouse"); # => "dog"


#def abbreviate_sentence(sent)
#    newWords = []
#    words = sent.split(" ") 
#
#    words.each do |word|
#        if word.length > 4
#            newWord = abbreviate_word(word)
#            newWords << newWord
#        else 
#            newWords << word
#        end
#    end
#    return newWords.join(" ")
#end
#def abbreviate_word(word)
#    vowels = "aeiou"
#    newWord = ""
#
#    word.each_char do |char|
#        if !vowels.include?(char)
#        newWord += char
#        end
#    end
#    return newWord
#end
#
#puts abbreviate_sentence("follow the yellow brick road") # => "fllw the yllw brck road"
#puts abbreviate_sentence("what a wonderful life")        # => "what a wndrfl life"


# Hint: use str.upcase and str.downcase
# "abc".upcase # => "ABC"

#def format_name(str)
#    propNames = []
#    names = str.split(" ")
#    corrected = ""
#    names.each do |name|
#        propNames << name[0].upcase + name[1..-1].downcase
#        corrected = propNames.join(" ")
#    end
#    return corrected
#end

#puts format_name("chase WILSON") # => "Chase Wilson"
#puts format_name("brian CrAwFoRd scoTT") # => "Brian Crawford Scott"



# A name is valid is if satisfies all of the following:
# - contains at least a first name and last name, separated by spaces
# - each part of the name should be capitalized
#
# Hint: use str.upcase or str.downcase
# "a".upcase # => "A"

#def is_valid_name(str)
#    parts = str.split(" ")
#    if parts.length < 2 
#        return false
#    end
#    parts.each do |part|
#        if !is_caps(part)
#            return false
#        end
#    end
#    return true
#end

#def is_caps(name)
#    if name[0] == name[0].upcase && name[1..-1] == name[1..-1].downcase
#        return true
#    else
#        return false
#    end
#    
#end

#puts is_valid_name("Kush Patel")       # => true
#puts is_valid_name("Daniel")           # => false
#puts is_valid_name("Robert Downey Jr") # => true
#puts is_valid_name("ROBERT DOWNEY JR") # => false



# For simplicity, we'll consider an email valid when it satisfies all of the following:
# - contains exactly one @ symbol
# - contains only lowercase alphabetic letters before the @
# - contains exactly one . after the @

#def is_valid_email(str)
#    parts = str.split("@")
#    
#    if parts.length != 2
#        return false
#    end
#
#    firstHalf = parts[0]
#    secondHalf = parts[1]
#    alpha = "abcdefghijklmnopqrstuvwxyz"
#    firstHalf.each_char do |char|
#       if !alpha.include?(char)
#            return false
#        end
#    end
#    if secondHalf.split(".").length != 2
#        return false
#    end
#    return true
#end



#puts is_valid_email("abc@xy.z")         # => true
#puts is_valid_email("jdoe@gmail.com")   # => true
#puts is_valid_email("jdoe@g@mail.com")  # => false
#puts is_valid_email("jdoe42@gmail.com") # => false
#puts is_valid_email("jdoegmail.com")    # => false
#puts is_valid_email("az@email")         # => false



#def reverse_words(sent)
#    words = sent.split(" ")
#    words.each do |word|
#        word.reverse!
#    end
#    return words.join(" ")
#end
#
#puts reverse_words('keep coding') # => 'peek gnidoc'
#puts reverse_words('simplicity is prerequisite for reliability') # => 'yticilpmis si etisiuqererp rof ytilibailer'



#def rotate_array(arr, num)
#    num.times do 
#        arr.unshift(arr[-1])
#        arr.pop()
#    end
#    return arr
#end

#print rotate_array([ "Matt", "Danny", "Mashu", "Matthias" ], 1) # => [ "Matthias", "Matt", "Danny", "Mashu" ]
#puts

#print rotate_array([ "a", "b", "c", "d" ], 2) # => [ "c", "d", "a", "b" ]
#puts



####################################################################################

#### Nested Loops & 2D Arrays ####

# Loops while inside the body of a loop
# num.to_s = converts a number to a string

# 2D array is an array with arrays inside
# Iterating through 2D arrays w/ nested loops, as 2D arrays are essentially nested arrays

####################

#   EXAMPLES   #


#def combinations(arr)
#    combined = []
#    subArr = []
#    arr.each_with_index do |ele1, index1|
#        arr.each_with_index do |ele2, index2|
#            if index2 > index1
#                subArr << ele1
#               subArr << ele2
#                combined << subArr
#            end
#            subArr = []
#        end
#    end
#    return combined
#end

#print combinations(["a", "b", "c"]); # => [ [ "a", "b" ], [ "a", "c" ], [ "b", "c" ] ]
#puts

#print combinations([0, 1, 2, 3]); # => [ [ 0, 1 ], [ 0, 2 ], [ 0, 3 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ]
#puts



#def opposite_count(nums)
#    i = 0
#    nums.each_with_index do |num1, index1|
#        nums.each_with_index do |num2, index2|
#            if index2 > index1 && num1 + num2 == 0
#                i += 1
#            end
#        end
#    end
#    return i
#end

#puts opposite_count([ 2, 5, 11, -5, -2, 7 ]) # => 2
#puts opposite_count([ 21, -23, 24 -12, 23 ]) # => 1




#def two_d_sum(arr)
#    count = 0
#    arr.each do |subArr|
#        subArr.each do |ele|
#            count += ele
#        end
#    end
#    return count
#end

#array_1 = [
#  [4, 5],
#  [1, 3, 7, 1]
#]
#puts two_d_sum(array_1)    # => 21

#array_2 = [
#  [3, 3],
#  [2],
#  [2, 5]
#]
#puts two_d_sum(array_2)    # => 15



#def two_d_translate(arr)
#    translated = []
#    arr.each do |subArr|
#        subArr[1].times do
#            translated << subArr[0]
#        end
#    end
#    return translated
#end

#arr_1 = [
#  ['boot', 3],
#  ['camp', 2],
#  ['program', 0]
#]

#print two_d_translate(arr_1) # => [ 'boot', 'boot', 'boot', 'camp', 'camp' ]
#puts

#arr_2 = [
#  ['red', 1],
#3  ['blue', 4]
#]

#print two_d_translate(arr_2) # => [ 'red', 'blue', 'blue', 'blue', 'blue' ]
#puts



#def array_translate(array)
#    translated = ""
#    i = 0
#    while i < array.length
#        count = array[i + 1]
#        word = array[i]
#        count.times do 
#            translated = translated + word
#        end
#        i += 2
#    end
#    return translated
#end

#print array_translate(["Cat", 2, "Dog", 3, "Mouse", 1]); # => "CatCatDogDogDogMouse"
#puts

#print array_translate(["red", 3, "blue", 1]); # => "redredredblue"
#puts



# Pig latin translation uses the following rules:
# - for words that start with a vowel, add 'yay' to the end
# - for words that start with a nonvowel, move all letters before the first vowel to the end of the word and add 'ay'

#def pig_latin_word(word)
#    vowels = ["a", "e", "i", "o", "u"]
#    pigLatin = ""
#    if vowels.include?(word[0])
#        pigLatin = word + "yay"
#    else
#        word.each_char.with_index do |char, index|
#            if vowels.include?(char)
#                pigLatin = word[index..-1] + word[0...index] + "ay"
#            end
#        end
#    end

#    return pigLatin
#end

#puts pig_latin_word("apple")   # => "appleyay"
#puts pig_latin_word("eat")     # => "eatyay"
#puts pig_latin_word("banana")  # => "ananabay"
#puts pig_latin_word("trash")   # => "ashtray"

####################################################################################

#### Hashes ####

# A new data structure
# 'key => value' - pairs

# my_hash = {"name" => "App Academy", "color" => "red", "age" => 5, "isAwsome" => true }
# puts my_hash["string"] #prints "App Academy"

#to change values
    # my_hash["color"] = "pink"
    # my_hash["age"] += 1

# Hash methods
    # .length = evaluates to amount of pairs in hash
    # .has_key?(k) 
    # .has_value?(v)
    # .keys = evaluates to an array of the keys
    # .values = evaluates to an array of the values
# can add value pairs after hash is defined by putting hash["key"] = "value"

# use hashes to have multiple data about a singular thing, use an array to have a collection of many similar things

# Hash enumerables
    # .each = need two outputs, for key and for value
    # .each_key
    # .each_value

# Hash default value is nil
# Hash.new(default)
# counter hash strategy
# counter hash
    #str = "mississipi"
    #count = Hash.new(0)
    #
    #str.each_char {|char| count[char] += 1}
    #this counts how many of each character are in a string
# sort_by
    # count.sort_by { |k, v| v }

# nil
    # represents "nothing" or "empty"
    # commonly appears as a default value

####################

#   EXAMPLES   #

####################

#def get_double_age(hash)
#    return hash["age"] * 2
#end

#puts get_double_age({"name"=>"App Academy", "age"=>5}) # => 10
#puts get_double_age({"name"=>"Ruby", "age"=>23})       # => 46